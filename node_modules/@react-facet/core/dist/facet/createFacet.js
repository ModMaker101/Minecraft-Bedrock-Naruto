"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFacet = void 0;
const equalityChecks_1 = require("../equalityChecks");
const types_1 = require("../types");
const scheduler_1 = require("../scheduler");
/**
 * The low level function to create a Facet, not recommended to be used if you can use any of the react facet hooks to create facets instead (Ex: useFacetState, useFacetWrap)
 */
function createFacet({ initialValue, startSubscription, equalityCheck = equalityChecks_1.defaultEqualityCheck, }) {
    const listeners = new Set();
    let currentValue = initialValue;
    let cleanupSubscription;
    const checker = equalityCheck === null || equalityCheck === void 0 ? void 0 : equalityCheck();
    const update = (newValue) => {
        if (equalityCheck !== undefined) {
            // we optimize for the most common scenario of using the defaultEqualityCheck (by inline its implementation)
            if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
                const typeofValue = typeof newValue;
                if ((typeofValue === 'number' ||
                    typeofValue === 'string' ||
                    typeofValue === 'boolean' ||
                    newValue === null ||
                    newValue === undefined) &&
                    currentValue === newValue) {
                    return;
                }
            }
            else {
                if (checker !== undefined && checker(newValue)) {
                    return;
                }
            }
        }
        (0, scheduler_1.batch)(() => {
            currentValue = newValue;
            for (const listener of listeners) {
                listener(currentValue);
            }
        });
    };
    /**
     * Simpler update implementation that only resets the value and runs all cleanup functions.
     * Done as a separated function to not interfere with the usual "hot-path" of the update function.
     */
    const updateToNoValue = () => {
        currentValue = types_1.NO_VALUE;
    };
    return {
        set: update,
        setWithCallback: (setter) => {
            const value = setter(currentValue);
            if (value === types_1.NO_VALUE) {
                updateToNoValue();
            }
            else {
                update(value);
            }
        },
        get: () => currentValue,
        observe: (listener) => {
            listeners.add(listener);
            if (currentValue !== types_1.NO_VALUE) {
                listener(currentValue);
            }
            // This is the first subscription, so we start subscribing to dependencies
            if (listeners.size === 1 && startSubscription) {
                cleanupSubscription = startSubscription(update);
            }
            return () => {
                listeners.delete(listener);
                // if this was the last to unsubscribe, we unsubscribe from our dependencies
                if (listeners.size === 0 && cleanupSubscription) {
                    currentValue = initialValue;
                    cleanupSubscription();
                }
            };
        },
    };
}
exports.createFacet = createFacet;
//# sourceMappingURL=createFacet.js.map