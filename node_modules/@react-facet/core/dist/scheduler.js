"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.batch = exports.cancelScheduledTask = exports.scheduleTask = void 0;
let batchId = 0;
let taskQueue = [];
/**
 * Schedules a given task to be executed at the end of a current batch, or runs it immediately if no batch is active.
 * @param task
 */
const scheduleTask = (task) => {
    // Not currently within a batch, so we execute the task immediately.
    if (batchId === 0) {
        task();
        return;
    }
    // Only schedules a task once within this batch execution.
    if (!task.scheduled) {
        task.scheduled = true;
        taskQueue.push(task);
    }
};
exports.scheduleTask = scheduleTask;
/**
 * Cancels the scheduling of a previously scheduled task.
 * @param task
 */
const cancelScheduledTask = (task) => {
    // Mark a task as canceled instead of removing it.
    // Its reference might already have been taken while processing the tasks.
    task.scheduled = false;
};
exports.cancelScheduledTask = cancelScheduledTask;
/**
 * Starts a batch, scheduling Facet updates within the cb to be executed at the end of the batch.
 * @param b will be executed immediately to collect Facet changes
 */
const batch = (b) => {
    // Starts a batch
    batchId += 1;
    try {
        b();
        // If this is the root batch, we start executing the tasks
        if (batchId === 1) {
            do {
                // Starts a new queue, as we work through the current one
                const taskQueueCopy = taskQueue;
                taskQueue = [];
                try {
                    for (let index = 0; index < taskQueueCopy.length; index++) {
                        const task = taskQueueCopy[index];
                        if (task.scheduled) {
                            task.scheduled = false;
                            task();
                        }
                    }
                }
                catch (e) {
                    // If something goes wrong, we unschedule all remaining tasks
                    for (let index = 0; index < taskQueueCopy.length; index++) {
                        const task = taskQueueCopy[index];
                        task.scheduled = false;
                    }
                    taskQueue = [];
                    throw e;
                }
                // Exhaust all tasks
            } while (taskQueue.length > 0);
        }
    }
    finally {
        // Ends a batch
        batchId -= 1;
    }
};
exports.batch = batch;
//# sourceMappingURL=scheduler.js.map