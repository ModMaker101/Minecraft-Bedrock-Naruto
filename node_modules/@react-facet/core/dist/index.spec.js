"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Import from the index to check for sure that APIs are correctly exposed
const react_1 = __importDefault(require("react"));
const facet = __importStar(require("."));
const _1 = require(".");
const dom_fiber_testing_library_1 = require("@react-facet/dom-fiber-testing-library");
describe('integration testing', () => {
    it('calls effects and corresponding clean up handlers properly when depending on a useFacetMap facet', () => {
        const demoFacet = (0, _1.createFacet)({ initialValue: { valueA: 'initialA', valueB: 'initialB' } });
        const cleanup = jest.fn();
        const effect = jest.fn((...args) => {
            return () => cleanup(...args);
        });
        const Scenario = () => {
            const valueAFacet = (0, _1.useFacetMap)(({ valueA }) => valueA, [], [demoFacet]);
            (0, _1.useFacetEffect)(effect, [], [valueAFacet]);
            return null;
        };
        const { rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(Scenario, null));
        // cleanup is not called immediately
        expect(cleanup).not.toHaveBeenCalled();
        // ...but the effect is
        expect(effect).toHaveBeenCalledTimes(1);
        expect(effect).toHaveBeenCalledWith('initialA');
        effect.mockClear();
        (0, dom_fiber_testing_library_1.act)(() => {
            demoFacet.set({ valueA: 'initialA', valueB: 'newB' });
        });
        // nothing should be called
        expect(cleanup).not.toHaveBeenCalled();
        expect(effect).not.toHaveBeenCalled();
        (0, dom_fiber_testing_library_1.act)(() => {
            demoFacet.set({ valueA: 'newA', valueB: 'newB' });
        });
        // once a new value is triggered we expect that the previous cleanup was called
        expect(cleanup).toHaveBeenCalledTimes(1);
        expect(cleanup).toHaveBeenCalledWith('initialA');
        // ...and the effect is called again with the new value
        expect(effect).toHaveBeenCalledTimes(1);
        expect(effect).toHaveBeenLastCalledWith('newA');
        cleanup.mockClear();
        effect.mockClear();
        // unmount the component to check if the cleanup is also called
        rerender(react_1.default.createElement(react_1.default.Fragment, null));
        // when the component unmounts we expect that we cleanup the last called effect
        expect(cleanup).toHaveBeenCalledTimes(1);
        expect(cleanup).toHaveBeenCalledWith('newA');
        // the effect shouldn't be called again on unmount
        expect(effect).not.toHaveBeenCalled();
    });
});
describe('regression testing preventing accidental removal of APIs', () => {
    it('exposes the components', () => {
        expect(facet.Map).toBeDefined();
        expect(facet.Mount).toBeDefined();
        expect(facet.With).toBeDefined();
    });
    it('exposes the core facets', () => {
        expect(facet.createFacet).toBeDefined();
        expect(facet.createStaticFacet).toBeDefined();
        expect(facet.createReadOnlyFacet).toBeDefined();
    });
    it('exposes the react facet methods', () => {
        expect(facet.createFacetContext).toBeDefined();
    });
    it('exposes the hooks', () => {
        expect(facet.useFacetCallback).toBeDefined();
        expect(facet.useFacetEffect).toBeDefined();
        expect(facet.useFacetLayoutEffect).toBeDefined();
        expect(facet.useFacetMap).toBeDefined();
        expect(facet.useFacetMemo).toBeDefined();
        expect(facet.useFacetPropSetter).toBeDefined();
        expect(facet.useFacetReducer).toBeDefined();
        expect(facet.useFacetRef).toBeDefined();
        expect(facet.useFacetState).toBeDefined();
        expect(facet.useFacetUnwrap).toBeDefined();
        expect(facet.useFacetWrap).toBeDefined();
    });
    it('exposes the equality checks', () => {
        expect(facet.strictEqualityCheck).toBeDefined();
        expect(facet.defaultEqualityCheck).toBeDefined();
        expect(facet.shallowArrayEqualityCheck).toBeDefined();
        expect(facet.shallowObjectArrayEqualityCheck).toBeDefined();
        expect(facet.createNullableEqualityCheck).toBeDefined();
        expect(facet.createUniformArrayEqualityCheck).toBeDefined();
        expect(facet.shallowObjectArrayEqualityCheck).toBeDefined();
        expect(facet.createOptionalValueEqualityCheck).toBeDefined();
        expect(facet.createUniformObjectEqualityCheck).toBeDefined();
        expect(facet.nullableShallowArrayEqualityCheck).toBeDefined();
        expect(facet.nullableShallowObjectEqualityCheck).toBeDefined();
        expect(facet.nullableShallowObjectArrayEqualityCheck).toBeDefined();
        expect(facet.createObjectWithKeySpecificEqualityCheck).toBeDefined();
    });
    it('exposes the mapFacets helpers', () => {
        expect(facet.mapFacetsCached).toBeDefined();
        expect(facet.mapFacetsLightweight).toBeDefined();
    });
});
//# sourceMappingURL=index.spec.js.map