"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const dom_fiber_testing_library_1 = require("@react-facet/dom-fiber-testing-library");
const useFacetCallback_1 = require("./useFacetCallback");
const useFacetEffect_1 = require("./useFacetEffect");
const useFacetMap_1 = require("./useFacetMap");
const types_1 = require("../types");
const facet_1 = require("../facet");
it('captures the current value of the facet in a function that can be used as handler', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'initial value' });
    const callback = jest.fn();
    const ComponentWithFacetCallback = ({ cb, dependency }) => {
        const handler = (0, useFacetCallback_1.useFacetCallback)((value) => (event) => {
            cb(value, dependency, event);
        }, [dependency, cb], [demoFacet]);
        (0, react_1.useEffect)(() => {
            handler('event');
        });
        return null;
    };
    const result = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetCallback, { cb: callback, dependency: "dependency" }));
    expect(callback).toHaveBeenCalledWith('initial value', 'dependency', 'event');
    // prepare mock for next check
    callback.mockClear();
    result.rerender(react_1.default.createElement(ComponentWithFacetCallback, { cb: callback, dependency: "dependency changed" }));
    expect(callback).toHaveBeenCalledWith('initial value', 'dependency changed', 'event');
    // prepare mock for next check
    callback.mockClear();
    // change the facet
    demoFacet.set('new value');
    result.rerender(react_1.default.createElement(ComponentWithFacetCallback, { cb: callback, dependency: "dependency changed" }));
    expect(callback).toHaveBeenCalledWith('new value', 'dependency changed', 'event');
});
it('properly memoizes the returned facet', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'initial value' });
    const TestComponent = () => {
        const previousCallbackRef = (0, react_1.useRef)();
        const callback = (0, useFacetCallback_1.useFacetCallback)(() => () => { }, [], [demoFacet]);
        // Check if it is a second render
        if (previousCallbackRef.current) {
            // check if previous and current are the same instance
            if (previousCallbackRef.current !== callback) {
                throw new Error('Callback instance has change');
            }
        }
        previousCallbackRef.current = callback;
        return null;
    };
    const { rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestComponent, null));
    // Render a second time to check (inside the component)
    // if the instance is the same
    rerender(react_1.default.createElement(TestComponent, null));
});
it('should work with uninitialized values', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: types_1.NO_VALUE });
    const callback = jest.fn();
    const ComponentWithFacetCallback = ({ cb }) => {
        const internalDemoFacet = (0, useFacetMap_1.useFacetMap)((facet) => facet + facet, [], [demoFacet]);
        const handler = (0, useFacetCallback_1.useFacetCallback)((value) => () => {
            cb(value);
        }, [cb], [internalDemoFacet]);
        (0, useFacetEffect_1.useFacetEffect)(() => {
            handler();
        }, [handler], [internalDemoFacet]);
        return null;
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetCallback, { cb: callback }));
    expect(callback).toHaveBeenCalledTimes(0);
    demoFacet.set('value');
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith('valuevalue');
});
it('supports multiple facets', () => {
    const facetA = (0, facet_1.createFacet)({ initialValue: 'a' });
    const facetB = (0, facet_1.createFacet)({ initialValue: 123 });
    const callback = jest.fn();
    let handler;
    const TestComponent = ({ dependency }) => {
        handler = (0, useFacetCallback_1.useFacetCallback)((valueA, valueB) => (event) => {
            callback(valueA, valueB, dependency, event);
        }, [dependency], [facetA, facetB]);
        return null;
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestComponent, { dependency: "dependency" }));
    (0, dom_fiber_testing_library_1.act)(() => {
        handler('event');
    });
    expect(callback).toHaveBeenCalledWith('a', 123, 'dependency', 'event');
});
it('returns NO_VALUE if any facet has NO_VALUE and skip calling the callback', () => {
    const facetA = (0, facet_1.createFacet)({ initialValue: 'a' });
    const facetB = (0, facet_1.createFacet)({ initialValue: types_1.NO_VALUE });
    const callback = jest.fn();
    let handler;
    const TestComponent = ({ dependency }) => {
        handler = (0, useFacetCallback_1.useFacetCallback)((valueA, valueB) => (event) => {
            callback(valueA, valueB, dependency, event);
        }, [dependency], [facetA, facetB]);
        return null;
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestComponent, { dependency: "dependency" }));
    (0, dom_fiber_testing_library_1.act)(() => {
        const result = handler('event');
        expect(result).toBe(types_1.NO_VALUE);
    });
    expect(callback).not.toHaveBeenCalledWith();
});
it('has proper return type with NO_VALUE in it', () => {
    const facetA = (0, facet_1.createFacet)({ initialValue: 'a' });
    let handler;
    const TestComponent = () => {
        handler = (0, useFacetCallback_1.useFacetCallback)((a) => (b) => {
            return a + b;
        }, [], [facetA]);
        return null;
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestComponent, null));
    (0, dom_fiber_testing_library_1.act)(() => {
        const result = handler('string');
        expect(result).toBe('astring');
    });
});
it('returns the defaultValue, when provided, if any facet has NO_VALUE and skip calling the callback', () => {
    const facetA = (0, facet_1.createFacet)({ initialValue: 'a' });
    const facetB = (0, facet_1.createFacet)({ initialValue: types_1.NO_VALUE });
    const callback = jest.fn();
    let handler;
    const TestComponent = ({ dependency }) => {
        handler = (0, useFacetCallback_1.useFacetCallback)((valueA, valueB) => (event) => {
            callback(valueA, valueB, dependency, event);
            return `${valueA} ${valueB}`;
        }, [dependency], [facetA, facetB], 'default value');
        return null;
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestComponent, { dependency: "dependency" }));
    (0, dom_fiber_testing_library_1.act)(() => {
        const result = handler('event');
        expect(result).toBe('default value');
    });
    expect(callback).not.toHaveBeenCalledWith();
});
describe('regressions', () => {
    it('should always have the current value of tracked facets', () => {
        const facetA = (0, facet_1.createFacet)({ initialValue: types_1.NO_VALUE });
        let handler = () => { };
        const TestComponent = () => {
            handler = (0, useFacetCallback_1.useFacetCallback)((a) => (b) => {
                return a + b;
            }, [], [facetA]);
            return null;
        };
        // We make sure to be the first listener registered, so this is called before
        // the listener within the useFacetCallback (which would have created the issue)
        facetA.observe(() => {
            const result = handler('string');
            expect(result).toBe('newstring');
        });
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestComponent, null));
        // In this act, the effect within useFacetCallback will be executed, subscribing for changes of the facetA
        // Then we set the value, causing the listener above to being called
        (0, dom_fiber_testing_library_1.act)(() => {
            facetA.set('new');
        });
    });
    it('should always have the current value of tracked facets (even after another component unmounts)', () => {
        const facetA = (0, facet_1.createFacet)({
            initialValue: types_1.NO_VALUE,
            // We need to have a value from a startSubscription so that after the last listener is removed, we set the facet back to NO_VALUE
            startSubscription: (update) => {
                update('value');
                return () => { };
            },
        });
        let handler = () => { };
        const TestComponentA = () => {
            handler = (0, useFacetCallback_1.useFacetCallback)((a) => (b) => {
                return a + b;
            }, [], [facetA]);
            return null;
        };
        const TestComponentB = () => {
            (0, useFacetCallback_1.useFacetCallback)(() => () => { }, [], [facetA]);
            return null;
        };
        // We mount both components, both internally calling the useFacetCallback to start subscriptions towards the facetA
        const { rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(react_1.default.Fragment, null,
            react_1.default.createElement(TestComponentA, null),
            react_1.default.createElement(TestComponentB, null)));
        // Then we unmount one of the components, causing it to unsubscribe from the facetA
        rerender(react_1.default.createElement(react_1.default.Fragment, null,
            react_1.default.createElement(TestComponentA, null)));
        // However, with a prior implementation, a shared instance of a listener (noop) was used across all useFacetCallback usages
        // causing a mismatch between calls to observer and unsubscribe.
        (0, dom_fiber_testing_library_1.act)(() => {
            const result = handler('string');
            expect(result).toBe('valuestring');
        });
    });
    it('always returns the same callback instance, even if the Facet instances change', () => {
        let handler = () => { };
        const facetA = (0, facet_1.createStaticFacet)('a');
        const facetB = (0, facet_1.createStaticFacet)('b');
        const TestComponent = ({ facet }) => {
            handler = (0, useFacetCallback_1.useFacetCallback)((a) => () => {
                return a;
            }, [], [facet]);
            return null;
        };
        const { rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestComponent, { facet: facetA }));
        const firstHandler = handler;
        expect(firstHandler()).toBe('a');
        rerender(react_1.default.createElement(TestComponent, { facet: facetB }));
        const secondHandler = handler;
        expect(secondHandler()).toBe('b');
        expect(firstHandler).toBe(secondHandler);
    });
});
//# sourceMappingURL=useFacetCallback.spec.js.map