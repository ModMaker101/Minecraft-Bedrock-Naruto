"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const dom_fiber_testing_library_1 = require("@react-facet/dom-fiber-testing-library");
const useFacetUnwrap_1 = require("./useFacetUnwrap");
const facet_1 = require("../facet");
const __1 = require("..");
describe('when mounting facets with values', () => {
    it('renders only once for Immutable value of type string', () => {
        const demoFacet = (0, facet_1.createFacet)({ initialValue: 'initial value' });
        const renderedMock = jest.fn();
        const ComponentWithFacetEffect = () => {
            const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
            renderedMock();
            return react_1.default.createElement("span", null, adaptValue);
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
        expect(renderedMock).toHaveBeenCalledTimes(1);
    });
    it('renders only once for Immutable value of type number', () => {
        const demoFacet = (0, facet_1.createFacet)({ initialValue: 1234 });
        const renderedMock = jest.fn();
        const ComponentWithFacetEffect = () => {
            const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
            renderedMock();
            return react_1.default.createElement("span", null, adaptValue);
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
        expect(renderedMock).toHaveBeenCalledTimes(1);
    });
    it('renders only once for Immutable value of type boolean', () => {
        const demoFacet = (0, facet_1.createFacet)({ initialValue: true });
        const renderedMock = jest.fn();
        const ComponentWithFacetEffect = () => {
            const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
            renderedMock();
            return react_1.default.createElement("span", null, adaptValue);
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
        expect(renderedMock).toHaveBeenCalledTimes(1);
    });
    it('renders only once for Immutable value of type undefined', () => {
        const demoFacet = (0, facet_1.createFacet)({ initialValue: undefined });
        const renderedMock = jest.fn();
        const ComponentWithFacetEffect = () => {
            const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
            renderedMock();
            return react_1.default.createElement("span", null, adaptValue);
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
        expect(renderedMock).toHaveBeenCalledTimes(1);
    });
    it('renders only once for Immutable value of type null', () => {
        const demoFacet = (0, facet_1.createFacet)({ initialValue: null });
        const renderedMock = jest.fn();
        const ComponentWithFacetEffect = () => {
            const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
            renderedMock();
            return react_1.default.createElement("span", null, adaptValue);
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
        expect(renderedMock).toHaveBeenCalledTimes(1);
    });
    // Ideally this should be one time, but unwrapping is mostly used for immutable values
    it('renders twice for Mutable values', () => {
        const demoFacet = (0, facet_1.createFacet)({ initialValue: [] });
        const renderedMock = jest.fn();
        const ComponentWithFacetEffect = () => {
            const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
            renderedMock();
            return react_1.default.createElement("span", null, adaptValue);
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
        expect(renderedMock).toHaveBeenCalledTimes(2);
    });
});
it('triggers when there is a change in the facet', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'initial value' });
    const ComponentWithFacetEffect = () => {
        const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
        return react_1.default.createElement("span", null, adaptValue);
    };
    const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
    const dom = (0, dom_fiber_testing_library_1.render)(scenario);
    expect(dom.container.textContent).toBe('initial value');
});
it('returns static values when given static values', () => {
    const ComponentWithFacetEffect = () => {
        const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)('static string');
        return react_1.default.createElement("span", null, adaptValue);
    };
    const dom = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
    expect(dom.container.textContent).toBe('static string');
});
it('re-renders when facet is mutated', () => {
    const mockFacetValue = {
        foo: 'foo',
    };
    const demoFacet = (0, facet_1.createFacet)({ initialValue: mockFacetValue });
    const ComponentWithFacetEffect = () => {
        const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
        if (adaptValue === __1.NO_VALUE)
            return null;
        return react_1.default.createElement("span", null, adaptValue.foo);
    };
    const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
    const { container } = (0, dom_fiber_testing_library_1.render)(scenario);
    expect(container.textContent).toBe('foo');
    (0, dom_fiber_testing_library_1.act)(() => {
        demoFacet.setWithCallback((prev) => {
            if (prev !== __1.NO_VALUE) {
                prev.foo = 'bar';
                return prev;
            }
            return {
                foo: 'banana',
            };
        });
    });
    expect(container.textContent).toBe('bar');
});
it('re-renders when facet is mutated to undefined', () => {
    const mockFacetValue = {
        foo: 'foo',
    };
    const demoFacet = (0, facet_1.createFacet)({ initialValue: mockFacetValue });
    const ComponentWithFacetEffect = () => {
        const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
        if (adaptValue === __1.NO_VALUE)
            return null;
        return react_1.default.createElement("span", null, adaptValue.foo);
    };
    const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
    const { container } = (0, dom_fiber_testing_library_1.render)(scenario);
    expect(container.textContent).toBe('foo');
    (0, dom_fiber_testing_library_1.act)(() => {
        demoFacet.setWithCallback((prev) => {
            if (prev !== __1.NO_VALUE) {
                prev.foo = undefined;
                return prev;
            }
            return {
                foo: 'banana',
            };
        });
    });
    expect(container.textContent).toBe('');
});
it('does not trigger a re-render when changing a facet from undefined to undefined', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: undefined });
    const renderedMock = jest.fn();
    const ComponentWithFacetEffect = () => {
        const adaptValue = (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet);
        renderedMock();
        return react_1.default.createElement("span", null, adaptValue);
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
    expect(renderedMock).toHaveBeenCalledTimes(1);
    renderedMock.mockClear();
    (0, dom_fiber_testing_library_1.act)(() => {
        demoFacet.set(undefined);
    });
    expect(renderedMock).toHaveBeenCalledTimes(0);
});
it('supports custom equality checks', () => {
    const value = { prop: 'initial' };
    const demoFacet = (0, facet_1.createFacet)({ initialValue: value });
    // Dummy equality check that always returns its not equal
    const check = jest.fn().mockReturnValue(false);
    const equalityCheck = jest.fn().mockReturnValue(check);
    const renderedMock = jest.fn();
    const ComponentWithFacetEffect = () => {
        (0, useFacetUnwrap_1.useFacetUnwrap)(demoFacet, equalityCheck);
        renderedMock();
        return null;
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
    // initialize equality checks once
    expect(equalityCheck).toHaveBeenCalledTimes(1);
    // but check for it twice, once upon initialization, then another on the first observed value
    expect(check).toHaveBeenCalledTimes(2);
    expect(check).toHaveBeenNthCalledWith(1, value);
    expect(check).toHaveBeenNthCalledWith(2, value);
    // as the custom equality check always returns false, we render twice on mount
    expect(renderedMock).toHaveBeenCalledTimes(2);
    jest.clearAllMocks();
    // If we update with the same object,
    (0, dom_fiber_testing_library_1.act)(() => {
        demoFacet.set(value);
    });
    expect(equalityCheck).toHaveBeenCalledTimes(0); // equality check was already initialized
    expect(check).toHaveBeenCalledTimes(1); // but the check should be executed
    expect(check).toHaveBeenCalledWith(value); // passing the value (which should be the same)
    expect(renderedMock).toHaveBeenCalledTimes(1); // and since the equality check always returns "false", we have a render
    jest.clearAllMocks();
    const newValue = { prop: 'new' };
    // If we update with a new object,
    (0, dom_fiber_testing_library_1.act)(() => {
        demoFacet.set(newValue);
    });
    expect(equalityCheck).toHaveBeenCalledTimes(0); // equality check was already initialized
    expect(check).toHaveBeenCalledTimes(1); // but the check should be executed
    expect(check).toHaveBeenCalledWith(newValue); // passing the new value
    expect(renderedMock).toHaveBeenCalledTimes(1); // and since the equality check always returns "false", we have a render
});
//# sourceMappingURL=useFacetUnwrap.spec.js.map