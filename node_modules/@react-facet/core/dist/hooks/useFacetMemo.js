"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFacetMemo = void 0;
const react_1 = require("react");
const equalityChecks_1 = require("../equalityChecks");
const mapFacets_1 = require("../mapFacets");
/**
 * Helper hook that allows mapping a value from a facet with local variables/props in a React component
 *
 * @param selector function that takes value from provided facets and maps them to a new value
 * @param dependencies variable used by the selector that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that we will listen for its values to be mapped
 * @param equalityCheck optional, has a default for immutable values
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 *
 * @returns a new facet definition that can be consumed as a regular facet
 */
function useFacetMemo(selector, dependencies, facets, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const selectorMemoized = (0, react_1.useCallback)(selector, dependencies);
    const facetComposition = (0, react_1.useMemo)(() => {
        return (0, mapFacets_1.mapFacetsCached)(facets, selectorMemoized, equalityCheck);
        // We need to disable the linter on the next line given we are spreading the facets as individual dependencies
        // of the effect. We do this to avoid re-running this effect when passing a new array with the same facets.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectorMemoized, equalityCheck, ...facets]);
    return facetComposition;
}
exports.useFacetMemo = useFacetMemo;
//# sourceMappingURL=useFacetMemo.js.map