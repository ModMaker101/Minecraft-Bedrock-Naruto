"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const dom_fiber_testing_library_1 = require("@react-facet/dom-fiber-testing-library");
const useFacetEffect_1 = require("./useFacetEffect");
const facet_1 = require("../facet");
const types_1 = require("../types");
it('triggers the effect on mount with the initial value and on any update of the facet', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'initial value' });
    const callback = jest.fn();
    const ComponentWithFacetEffect = () => {
        (0, useFacetEffect_1.useFacetEffect)(callback, [], [demoFacet]);
        return null;
    };
    const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
    (0, dom_fiber_testing_library_1.render)(scenario);
    expect(callback).toHaveBeenCalledWith('initial value');
    // prepare mock for next check
    callback.mockClear();
    // change the facet
    (0, dom_fiber_testing_library_1.act)(() => {
        demoFacet.set('new value');
    });
    // verify that it was called again, but with the new value
    expect(callback).toHaveBeenCalledWith('new value');
});
it('triggers the effect when a dependency changes', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'initial value' });
    const callback = jest.fn();
    const ComponentWithFacetEffect = ({ dependency }) => {
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            callback(`${value} ${dependency}`);
        }, [dependency], [demoFacet]);
        return null;
    };
    const { rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, { dependency: 0 }));
    expect(callback).toHaveBeenCalledWith('initial value 0');
    // clear the mock, since it was called on the mount
    callback.mockClear();
    // change the dependency
    rerender(react_1.default.createElement(ComponentWithFacetEffect, { dependency: 1 }));
    // verify that the effect was called
    expect(callback).toHaveBeenCalledWith('initial value 1');
});
describe('cleanup', () => {
    it('handles cleanup the effect on changing the value and unmounting', () => {
        const demoFacet = (0, facet_1.createFacet)({ initialValue: 'initial value' });
        const cleanup = jest.fn();
        const effect = jest.fn((...args) => {
            return () => cleanup(...args);
        });
        const ComponentWithFacetEffect = () => {
            (0, useFacetEffect_1.useFacetEffect)(effect, [], [demoFacet]);
            return null;
        };
        const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
        const { rerender } = (0, dom_fiber_testing_library_1.render)(scenario);
        // cleanup is not called immediately
        expect(cleanup).not.toHaveBeenCalled();
        // ...but the effect is
        expect(effect).toHaveBeenCalledTimes(1);
        expect(effect).toHaveBeenCalledWith('initial value');
        effect.mockClear();
        (0, dom_fiber_testing_library_1.act)(() => {
            demoFacet.set('new value');
        });
        // once a new value is triggered we expect that the previous cleanup was called
        expect(cleanup).toHaveBeenCalledTimes(1);
        expect(cleanup).toHaveBeenCalledWith('initial value');
        // ...and the effect is called again with the new value
        expect(effect).toHaveBeenCalledTimes(1);
        expect(effect).toHaveBeenLastCalledWith('new value');
        cleanup.mockClear();
        effect.mockClear();
        // unmount the component to check if the cleanup is also called
        rerender(react_1.default.createElement(react_1.default.Fragment, null));
        // when the component unmounts we expect that we cleanup the last called effect
        expect(cleanup).toHaveBeenCalledTimes(1);
        expect(cleanup).toHaveBeenCalledWith('new value');
        // the effect shouldn't be called again on unmount
        expect(effect).not.toHaveBeenCalled();
    });
});
it('supports multiple facets, only triggering the effect once all facets have a value', () => {
    const facetA = (0, facet_1.createFacet)({ initialValue: 'initial value' });
    const facetB = (0, facet_1.createFacet)({ initialValue: types_1.NO_VALUE });
    const cleanup = jest.fn();
    const effect = jest.fn().mockReturnValue(cleanup);
    const ComponentWithFacetEffect = () => {
        (0, useFacetEffect_1.useFacetEffect)(effect, [], [facetA, facetB]);
        return null;
    };
    const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
    const { rerender } = (0, dom_fiber_testing_library_1.render)(scenario);
    expect(cleanup).not.toHaveBeenCalled();
    expect(effect).not.toHaveBeenCalled();
    effect.mockClear();
    cleanup.mockClear();
    // change only the initialized facet
    (0, dom_fiber_testing_library_1.act)(() => {
        facetA.set('new value');
    });
    // expect that the effect was not called
    expect(cleanup).not.toHaveBeenCalled();
    expect(effect).not.toHaveBeenCalled();
    effect.mockClear();
    cleanup.mockClear();
    // set a value for the second facet
    (0, dom_fiber_testing_library_1.act)(() => {
        facetB.set(123);
    });
    // verify that the effect was finally called with both values
    expect(cleanup).not.toHaveBeenCalled();
    expect(effect).toHaveBeenCalledWith('new value', 123);
    expect(effect).toHaveBeenCalledTimes(1);
    effect.mockClear();
    cleanup.mockClear();
    // update the first facet again
    (0, dom_fiber_testing_library_1.act)(() => {
        facetA.set('one more update');
    });
    // verify that the effect was called again, and now we verify that the previous cleanup was called
    expect(cleanup).toHaveBeenCalledTimes(1);
    expect(effect).toHaveBeenCalledWith('one more update', 123);
    expect(effect).toHaveBeenCalledTimes(1);
    effect.mockClear();
    cleanup.mockClear();
    // and finally we unmount the component
    rerender(react_1.default.createElement(react_1.default.Fragment, null));
    // then we get a final cleanup, without the effect being fired
    expect(cleanup).toHaveBeenCalledTimes(1);
    expect(effect).not.toHaveBeenCalled();
});
//# sourceMappingURL=useFacetEffect.spec.js.map