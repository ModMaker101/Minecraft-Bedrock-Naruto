"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFacetUnwrap = void 0;
const react_1 = require("react");
const types_1 = require("../types");
const equalityChecks_1 = require("../equalityChecks");
/**
 * Hook that allows consuming values from a Facet
 * It acts as a regular react state, triggering a re-render of the component
 *
 * @param facet
 */
function useFacetUnwrap(prop, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    const [state, setState] = (0, react_1.useState)(() => {
        if (!(0, types_1.isFacet)(prop))
            return { value: prop };
        return {
            value: prop.get(),
        };
    });
    (0, react_1.useLayoutEffect)(() => {
        if ((0, types_1.isFacet)(prop)) {
            // Initialize the equalityCheck
            const isEqual = equalityCheck();
            const startValue = prop.get();
            if (startValue !== types_1.NO_VALUE) {
                isEqual(startValue);
            }
            return prop.observe((value) => {
                setState((previousState) => {
                    const { value: previousValue } = previousState;
                    /**
                     * Performs this equality check locally to prevent triggering two consecutive renderings
                     * for facets that have immutable values (unfortunately we can't handle mutable values).
                     *
                     * The two renderings might happen for the same state value if the Facet has a value on mount.
                     *
                     * The unwrap will get the value:
                     * - Once on initialization of the useState above
                     * - And another time on this observe initialization
                     */
                    if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
                        const typeofValue = typeof previousValue;
                        if ((typeofValue === 'number' ||
                            typeofValue === 'string' ||
                            typeofValue === 'boolean' ||
                            value === undefined ||
                            value === null) &&
                            value === previousValue) {
                            return previousState;
                        }
                        return { value };
                    }
                    if (previousValue !== types_1.NO_VALUE && isEqual(value)) {
                        return previousState;
                    }
                    return { value };
                });
            });
        }
    }, [prop, equalityCheck]);
    return (0, types_1.isFacet)(prop) ? state.value : prop;
}
exports.useFacetUnwrap = useFacetUnwrap;
//# sourceMappingURL=useFacetUnwrap.js.map