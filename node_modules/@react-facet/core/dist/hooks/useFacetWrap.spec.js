"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const dom_fiber_testing_library_1 = require("@react-facet/dom-fiber-testing-library");
const useFacetWrap_1 = require("./useFacetWrap");
const useFacetEffect_1 = require("./useFacetEffect");
const useFacetMap_1 = require("./useFacetMap");
const facet_1 = require("../facet");
it('wraps a value, updating the facet when it changes', () => {
    const mock = jest.fn();
    const ComponentWithFacetEffect = ({ value }) => {
        const facetifiedValue = (0, useFacetWrap_1.useFacetWrap)(value);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetifiedValue]);
        return react_1.default.createElement("span", null);
    };
    const dom = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, { value: "value" }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
    mock.mockClear();
    dom.rerender(react_1.default.createElement(ComponentWithFacetEffect, { value: "changed" }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('changed');
});
it('wraps a value, with the default equality check (preventing unnecessary updates)', () => {
    const mock = jest.fn();
    const ComponentWithFacetEffect = ({ value }) => {
        const facetifiedValue = (0, useFacetWrap_1.useFacetWrap)(value);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetifiedValue]);
        return react_1.default.createElement("span", null);
    };
    const dom = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, { value: "value" }));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
    mock.mockClear();
    dom.rerender(react_1.default.createElement(ComponentWithFacetEffect, { value: "value" }));
    expect(mock).toHaveBeenCalledTimes(0);
});
it('forwards a facet', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'value' });
    const mock = jest.fn();
    const ComponentWithFacetEffect = () => {
        const facetifiedValue = (0, useFacetWrap_1.useFacetWrap)(demoFacet);
        (0, useFacetEffect_1.useFacetEffect)((value) => {
            mock(value);
        }, [], [facetifiedValue]);
        return react_1.default.createElement("span", null);
    };
    (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(ComponentWithFacetEffect, null));
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('value');
    mock.mockClear();
    demoFacet.set('changed');
    expect(mock).toHaveBeenCalledTimes(1);
    expect(mock).toHaveBeenCalledWith('changed');
});
it('updates correctly if the facet instance change (ex: via a useFacetMap)', () => {
    const demoFacet = (0, facet_1.createFacet)({ initialValue: 'value' });
    const TestingComponent = ({ concat }) => {
        // When a dependency of useFacetMap change (concat) a new facet is created
        // And when we pass that to the useFacetWrap we need to make sure that it gets propagated
        return (react_1.default.createElement("span", null,
            react_1.default.createElement("fast-text", { text: (0, useFacetWrap_1.useFacetWrap)((0, useFacetMap_1.useFacetMap)((value) => `${value} ${concat}`, [concat], [demoFacet])) })));
    };
    const { container, rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestingComponent, { concat: "123" }));
    expect(container).toHaveTextContent('value 123');
    rerender(react_1.default.createElement(TestingComponent, { concat: "456" }));
    expect(container).toHaveTextContent('value 456');
});
describe('regressions', () => {
    it('should not immediately call a function when wrapped', () => {
        const mock = jest.fn();
        const TestingComponent = () => {
            const handlerFacet = (0, useFacetWrap_1.useFacetWrap)(mock);
            (0, useFacetEffect_1.useFacetEffect)(() => undefined, [], [handlerFacet]);
            return null;
        };
        (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestingComponent, null));
        expect(mock).toHaveBeenCalledTimes(0);
    });
});
const testEffectUpdatesOnStaticValue = (value, expectUpdates) => {
    const mock = jest.fn();
    const TestingComponent = () => {
        const undefinedFacet = (0, useFacetWrap_1.useFacetWrap)(value);
        (0, useFacetEffect_1.useFacetEffect)(() => {
            mock();
        }, [], [undefinedFacet]);
        return null;
    };
    const { rerender } = (0, dom_fiber_testing_library_1.render)(react_1.default.createElement(TestingComponent, null));
    expect(mock).toHaveBeenCalledTimes(1);
    rerender(react_1.default.createElement(TestingComponent, null));
    if (expectUpdates) {
        expect(mock).toHaveBeenCalledTimes(2);
    }
    else {
        expect(mock).toHaveBeenCalledTimes(1);
    }
    rerender(react_1.default.createElement(TestingComponent, null));
    if (expectUpdates) {
        expect(mock).toHaveBeenCalledTimes(3);
    }
    else {
        expect(mock).toHaveBeenCalledTimes(1);
    }
};
describe('does not trigger effect updates on re-renders when the unchanged wrapped value is', () => {
    it('string', () => {
        testEffectUpdatesOnStaticValue('', false);
        testEffectUpdatesOnStaticValue('test', false);
    });
    it('boolean', () => {
        testEffectUpdatesOnStaticValue(false, false);
        testEffectUpdatesOnStaticValue(true, false);
    });
    it('number', () => {
        testEffectUpdatesOnStaticValue(0, false);
        testEffectUpdatesOnStaticValue(1, false);
    });
    it('undefined', () => {
        testEffectUpdatesOnStaticValue(undefined, false);
    });
    it('null', () => {
        testEffectUpdatesOnStaticValue(null, false);
    });
});
describe('triggers effect updates on re-renders when the unchanged wrapped value is', () => {
    it('empty array', () => {
        testEffectUpdatesOnStaticValue([], true);
    });
    it('filled array', () => {
        testEffectUpdatesOnStaticValue(['string', 1], true);
    });
    it('empty object', () => {
        testEffectUpdatesOnStaticValue({}, true);
    });
    it('filled object', () => {
        testEffectUpdatesOnStaticValue({ key: 'value' }, true);
    });
});
//# sourceMappingURL=useFacetWrap.spec.js.map