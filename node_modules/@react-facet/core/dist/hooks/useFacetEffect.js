"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFacetEffect = exports.createUseFacetEffect = void 0;
const react_1 = require("react");
const types_1 = require("../types");
const scheduler_1 = require("../scheduler");
const createUseFacetEffect = (useHook) => {
    return function (effect, dependencies, facets) {
        // eslint-disable-next-line react-hooks/exhaustive-deps
        const effectMemoized = (0, react_1.useCallback)(effect, dependencies);
        useHook(() => {
            let cleanup;
            if (facets.length === 1) {
                const unsubscribe = facets[0].observe((value) => {
                    if (cleanup !== undefined) {
                        cleanup();
                    }
                    cleanup = effectMemoized(value);
                });
                return () => {
                    unsubscribe();
                    if (cleanup !== undefined) {
                        cleanup();
                    }
                };
            }
            let hasAllDependencies = false;
            const unsubscribes = [];
            const values = facets.map(() => types_1.NO_VALUE);
            const task = () => {
                hasAllDependencies = hasAllDependencies || values.every((value) => value !== types_1.NO_VALUE);
                if (hasAllDependencies) {
                    if (cleanup !== undefined) {
                        cleanup();
                    }
                    cleanup = effectMemoized(...values);
                }
            };
            facets.forEach((facet, index) => {
                unsubscribes[index] = facet.observe((value) => {
                    values[index] = value;
                    if (hasAllDependencies) {
                        (0, scheduler_1.scheduleTask)(task);
                    }
                    else {
                        task();
                    }
                });
            });
            return () => {
                (0, scheduler_1.cancelScheduledTask)(task);
                unsubscribes.forEach((unsubscribe) => unsubscribe());
                if (cleanup !== undefined) {
                    cleanup();
                }
            };
            // We care about each individual facet and if any is a different reference
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [effectMemoized, ...facets]);
    };
};
exports.createUseFacetEffect = createUseFacetEffect;
/**
 * Allows running an effect based on facet updates. Similar to React's useEffect.
 *
 * @param effect function that will do the side-effect (ex: update the DOM)
 * @param dependencies variable used by the map that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that the effect listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
exports.useFacetEffect = (0, exports.createUseFacetEffect)(react_1.useEffect);
//# sourceMappingURL=useFacetEffect.js.map