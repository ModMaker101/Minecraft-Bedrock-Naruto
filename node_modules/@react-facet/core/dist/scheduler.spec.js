"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const facet_1 = require("./facet");
const hooks_1 = require("./hooks");
const mapFacets_1 = require("./mapFacets");
const scheduler_1 = require("./scheduler");
const dom_fiber_testing_library_1 = require("@react-facet/dom-fiber-testing-library");
/**
 * Integration test to demonstrate the main motivation for batching and scheduling
 */
it('batches maps and effects', () => {
    const friendsCountFacet = (0, facet_1.createFacet)({ initialValue: 42 });
    const userFacet = (0, facet_1.createFacet)({ initialValue: { name: 'Initial Name', login: 'Initial Login' } });
    const cleanup = jest.fn();
    const effect = jest.fn().mockReturnValue(cleanup);
    // The useFacetMaps in the component below are within a single component,
    // but more realistically you can think that they would be distributed across a React tree.
    const ComponentWithFacetEffect = () => {
        // Its not unusual to want to combine data from multiple Facet sources
        const userWithFriends = (0, hooks_1.useFacetMap)((user, friendsCount) => (Object.assign(Object.assign({}, user), { friendsCount })), [], [userFacet, friendsCountFacet]);
        // Another very common scenario with Facets is that we can map them into more specific values
        const nameFacet = (0, hooks_1.useFacetMap)(({ name }) => name, [], [userWithFriends]);
        const loginFacet = (0, hooks_1.useFacetMap)(({ login }) => login, [], [userWithFriends]);
        // But then we might decide again on combining both on a single effect
        (0, hooks_1.useFacetEffect)(effect, [], [nameFacet, loginFacet]);
        return null;
    };
    const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
    // Guarantees that within a batch, we execute the effect task immediately (if the data is available on mount)
    (0, scheduler_1.batch)(() => {
        (0, dom_fiber_testing_library_1.render)(scenario);
        expect(effect).toHaveBeenCalledWith('Initial Name', 'Initial Login');
        expect(effect).toHaveBeenCalledTimes(1);
    });
    effect.mockClear();
    cleanup.mockClear();
    (0, dom_fiber_testing_library_1.act)(() => {
        // On updating the facet, we should expect that the effect is called only once
        // Without batching, it would have been called twice
        (0, scheduler_1.batch)(() => {
            userFacet.set({ name: 'New Name', login: 'New Login' });
        });
    });
    expect(cleanup).toHaveBeenCalledTimes(1);
    expect(effect).toHaveBeenCalledWith('New Name', 'New Login');
    expect(effect).toHaveBeenCalledTimes(1);
});
describe('order of execution', () => {
    it('runs tasks within a batch in the correct order', () => {
        const order = [];
        const taskB = jest.fn().mockImplementation(() => order.push('B'));
        const taskA = jest.fn().mockImplementation(() => order.push('A'));
        const taskC = jest.fn().mockImplementation(() => order.push('C'));
        (0, scheduler_1.batch)(() => {
            (0, scheduler_1.scheduleTask)(taskA);
            (0, scheduler_1.scheduleTask)(taskB);
            (0, scheduler_1.batch)(() => {
                (0, scheduler_1.scheduleTask)(taskC);
            });
        });
        expect(order).toEqual(['A', 'B', 'C']);
    });
    it('runs tasks of nested batches in the correct order', () => {
        const order = [];
        const taskC = jest.fn().mockImplementation(() => {
            order.push('C');
        });
        const taskB = jest.fn().mockImplementation(() => {
            order.push('B');
            (0, scheduler_1.batch)(() => {
                (0, scheduler_1.scheduleTask)(taskC);
            });
        });
        const taskA = jest.fn().mockImplementation(() => {
            order.push('A');
            (0, scheduler_1.batch)(() => {
                (0, scheduler_1.scheduleTask)(taskB);
            });
        });
        (0, scheduler_1.batch)(() => {
            (0, scheduler_1.scheduleTask)(taskA);
        });
        expect(order).toEqual(['A', 'B', 'C']);
    });
    it('cancels tasks while executing prior tasks', () => {
        const order = [];
        const taskB = jest.fn().mockImplementation(() => order.push('B'));
        const taskA = jest.fn().mockImplementation(() => {
            order.push('A');
            (0, scheduler_1.cancelScheduledTask)(taskB);
        });
        (0, scheduler_1.batch)(() => {
            (0, scheduler_1.scheduleTask)(taskA);
            (0, scheduler_1.scheduleTask)(taskB);
        });
        expect(order).toEqual(['A']);
    });
    it('handles exceptions gracefully', () => {
        let order = [];
        const taskC = jest.fn().mockImplementation(() => order.push('C'));
        const taskB = jest.fn().mockImplementation(() => {
            throw new Error('Task failed');
        });
        const taskA = jest.fn().mockImplementation(() => order.push('A'));
        // Once a batch fails
        expect(() => {
            (0, scheduler_1.batch)(() => {
                (0, scheduler_1.scheduleTask)(taskA);
                (0, scheduler_1.scheduleTask)(taskB);
                (0, scheduler_1.scheduleTask)(taskC);
            });
        }).toThrow();
        // Validate that we have executed the tasks until the exception
        expect(order).toEqual(['A']);
        // And starting a new batch, should work just fine
        order = [];
        (0, scheduler_1.batch)(() => {
            (0, scheduler_1.scheduleTask)(taskA);
            (0, scheduler_1.scheduleTask)(taskC);
        });
        expect(order).toEqual(['A', 'C']);
    });
});
describe('mapping an array of facets', () => {
    it('supports batching', () => {
        const facetA = (0, facet_1.createFacet)({ initialValue: 'a1' });
        const facetB = (0, facet_1.createFacet)({ initialValue: 'b1' });
        const facetAB = (0, mapFacets_1.mapFacetsLightweight)([facetA, facetB], (a, b) => `${a} ${b}`);
        const observer = jest.fn();
        facetAB.observe(observer);
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('a1 b1');
        jest.clearAllMocks();
        (0, scheduler_1.batch)(() => {
            facetA.set('a2');
            facetB.set('b2');
        });
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('a2 b2');
    });
    it('avoids scheduling (within a batch) if its the first event of a subscription', () => {
        const facetA = (0, facet_1.createFacet)({ initialValue: 'a1' });
        const facetB = (0, facet_1.createFacet)({ initialValue: 'b1' });
        const facetAB = (0, mapFacets_1.mapFacetsLightweight)([facetA, facetB], (a, b) => `${a} ${b}`);
        const observer = jest.fn();
        (0, scheduler_1.batch)(() => {
            facetAB.observe(observer);
            // It should fire immediately, and not after the batch
            expect(observer).toHaveBeenCalledTimes(1);
            expect(observer).toHaveBeenCalledWith('a1 b1');
        });
        // Didn't call again after the batch ended
        expect(observer).toHaveBeenCalledTimes(1);
    });
    it('supports batching, but nested', () => {
        const facetA = (0, facet_1.createFacet)({ initialValue: 'a1' });
        const facetB = (0, facet_1.createFacet)({ initialValue: 'b1' });
        const facetAB = (0, mapFacets_1.mapFacetsLightweight)([facetA, facetB], (a, b) => `${a} ${b}`);
        const observer = jest.fn();
        facetAB.observe(observer);
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('a1 b1');
        jest.clearAllMocks();
        (0, scheduler_1.batch)(() => {
            facetA.set('a2');
            (0, scheduler_1.batch)(() => {
                facetB.set('b2');
            });
        });
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('a2 b2');
    });
    it('batches a single facet mapped into multiple facets and then combined again', () => {
        const facet = (0, facet_1.createFacet)({ initialValue: 'a' });
        const first = (0, mapFacets_1.mapFacetsLightweight)([facet], (a) => `first ${a}`);
        const second = (0, mapFacets_1.mapFacetsLightweight)([facet], (a) => `second ${a}`);
        const combinedAgain = (0, mapFacets_1.mapFacetsLightweight)([first, second], (a, b) => `${a},${b}`);
        const observer = jest.fn();
        combinedAgain.observe(observer);
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('first a,second a');
        jest.clearAllMocks();
        facet.set('b');
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('first b,second b');
    });
    it('batches side-effects of other batches', () => {
        const derivativeFacet = (0, facet_1.createFacet)({ initialValue: 'a' });
        const derivativeFacetFirst = (0, mapFacets_1.mapFacetsLightweight)([derivativeFacet], (a) => `first ${a}`);
        const derivativeFacetSecond = (0, mapFacets_1.mapFacetsLightweight)([derivativeFacet], (a) => `second ${a}`);
        const derivativeFacetMapped = (0, mapFacets_1.mapFacetsLightweight)([derivativeFacetFirst, derivativeFacetSecond], (a, b) => `${a},${b}`);
        const sourceFacetA = (0, facet_1.createFacet)({ initialValue: 'a1' });
        const sourceFacetB = (0, facet_1.createFacet)({ initialValue: 'b1' });
        const mappedFacetAAndFacetB = (0, mapFacets_1.mapFacetsLightweight)([sourceFacetA, sourceFacetB], (a, b) => `${a}_${b}`);
        const observer = jest.fn();
        mappedFacetAAndFacetB.observe((value) => {
            derivativeFacet.set(value);
        });
        derivativeFacetMapped.observe(observer);
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('first a1_b1,second a1_b1');
        jest.clearAllMocks();
        // this batch groups with the batch that's called as an effect of it's function call contents
        (0, scheduler_1.batch)(() => {
            sourceFacetA.set('a2');
            sourceFacetB.set('b2');
        });
        expect(observer).toHaveBeenCalledTimes(1);
        expect(observer).toHaveBeenCalledWith('first a2_b2,second a2_b2');
    });
});
describe('effects with multiple facet dependencies', () => {
    it('batches dependencies of an effect', () => {
        const facetA = (0, facet_1.createFacet)({ initialValue: 'facetA' });
        const facetB = (0, facet_1.createFacet)({ initialValue: 'facetB' });
        const cleanup = jest.fn();
        const effect = jest.fn().mockReturnValue(cleanup);
        const ComponentWithFacetEffect = () => {
            (0, hooks_1.useFacetEffect)(effect, [], [facetA, facetB]);
            return null;
        };
        const scenario = react_1.default.createElement(ComponentWithFacetEffect, null);
        const { rerender } = (0, dom_fiber_testing_library_1.render)(scenario);
        expect(cleanup).not.toHaveBeenCalled();
        expect(effect).toHaveBeenCalledWith('facetA', 'facetB');
        expect(effect).toHaveBeenCalledTimes(1);
        effect.mockClear();
        cleanup.mockClear();
        // set a value for the second facet
        (0, dom_fiber_testing_library_1.act)(() => {
            (0, scheduler_1.batch)(() => {
                facetA.set('facetA-updated');
                facetB.set('facetB-updated');
            });
        });
        // Runs the previous cleanup, then runs the effect only once
        expect(cleanup).toHaveBeenCalled();
        expect(cleanup).toHaveBeenCalledTimes(1);
        expect(effect).toHaveBeenCalledWith('facetA-updated', 'facetB-updated');
        expect(effect).toHaveBeenCalledTimes(1);
        effect.mockClear();
        cleanup.mockClear();
        // and finally we unmount the component
        rerender(react_1.default.createElement(react_1.default.Fragment, null));
        // then we get a final cleanup, without the effect being fired
        expect(cleanup).toHaveBeenCalledTimes(1);
        expect(effect).not.toHaveBeenCalled();
    });
});
//# sourceMappingURL=scheduler.spec.js.map