"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOptionalValueEqualityCheck = exports.createObjectWithKeySpecificEqualityCheck = exports.createUniformArrayEqualityCheck = exports.createUniformObjectEqualityCheck = exports.createNullableEqualityCheck = void 0;
const types_1 = require("./types");
/**
 * Creates an equality check that accepts null and undefined values
 *
 * @param comparator comparator to be wrapped with the null check
 */
const createNullableEqualityCheck = (comparator) => {
    const check = comparator();
    let previous = types_1.NO_VALUE;
    return (value) => {
        if (value === undefined || value === null || previous === undefined || previous === null) {
            if (value !== previous) {
                previous = value;
                return false;
            }
            else {
                return true;
            }
        }
        previous = value;
        return check(value);
    };
};
exports.createNullableEqualityCheck = createNullableEqualityCheck;
/**
 * Creates an equality check that tests that the values of all the properties in an object
 * haven't changed.
 *
 * The comparison used for the value of the properties is passed to it as an argument.
 *
 * @param comparator the equality check to be run for each property
 */
const createUniformObjectEqualityCheck = (comparator) => () => {
    const previous = {};
    let previousKeys = new Set();
    let initialized = false;
    return (current) => {
        var _a;
        let isEquals = true;
        for (const key in current) {
            if (!(key in previous)) {
                previous[key] = comparator();
            }
            if (!((_a = previous[key]) === null || _a === void 0 ? void 0 : _a.call(previous, current[key]))) {
                isEquals = false;
            }
            previousKeys.delete(key);
        }
        if (previousKeys.size > 0) {
            for (const key of previousKeys) {
                delete previous[key];
            }
            isEquals = false;
        }
        previousKeys = new Set();
        for (const key in current) {
            previousKeys.add(key);
        }
        if (!initialized) {
            initialized = true;
            return false;
        }
        return isEquals;
    };
};
exports.createUniformObjectEqualityCheck = createUniformObjectEqualityCheck;
/**
 * Creates an equality check that tests that the items in an array
 * haven't changed.
 *
 * The comparison used for the individual items is passed to it as an argument.
 *
 * @param comparator the equality check to be run for each item
 */
const createUniformArrayEqualityCheck = (comparator) => () => {
    const previous = [];
    let initialized = false;
    return (current) => {
        var _a, _b;
        const longestLength = Math.max((_a = previous === null || previous === void 0 ? void 0 : previous.length) !== null && _a !== void 0 ? _a : 0, (_b = current === null || current === void 0 ? void 0 : current.length) !== null && _b !== void 0 ? _b : 0);
        let isEquals = true;
        for (let i = 0; i < longestLength; i++) {
            if (previous[i] === undefined) {
                previous[i] = comparator();
            }
            if (!previous[i](current[i])) {
                isEquals = false;
            }
        }
        if (!initialized) {
            initialized = true;
            return false;
        }
        return isEquals;
    };
};
exports.createUniformArrayEqualityCheck = createUniformArrayEqualityCheck;
/**
 * Creates an equality check that tests whether each property of the target object has changed.
 * Each property is tested with a different comparator, so that they can be of different types.
 *
 * The comparator are passed down to it as an object with the same keys as the target object, but
 * comparators for each property as values.
 *
 * @param comparators the object containing the equality checks to be run for each property
 */
const createObjectWithKeySpecificEqualityCheck = (comparators) => () => {
    const initializingComparators = {};
    for (const key in comparators) {
        initializingComparators[key] = comparators[key]();
    }
    const initializedComparators = initializingComparators;
    return (current) => {
        let isEqual = true;
        for (const key in current) {
            if (!initializedComparators[key](current[key])) {
                // We don't break or skip the next comparators because we need all comparators
                // to run for their internal values to update, so we complete the for loop
                // even if one of the comparators reports false early on
                isEqual = false;
            }
        }
        return isEqual;
    };
};
exports.createObjectWithKeySpecificEqualityCheck = createObjectWithKeySpecificEqualityCheck;
/**
 * Creates an equality check that tests whether the value changed from null to defined or stayed the same
 *
 * If the value was not null before and it is not null currently, the comparison is done by the equality check
 * provided as an argument to this creator.
 *
 * This creator is useful to be able to make equality checkers for optional properties when you already have
 * an equality check for the underlying type.
 *
 * @param comparator the equality check to be run in case the value was defined before and now
 */
const createOptionalValueEqualityCheck = (comparator) => () => {
    let previousWasNullish = true;
    let initializedComparator = comparator();
    return (current) => {
        if (current === undefined || current === null) {
            if (previousWasNullish) {
                return true;
            }
            // If the next value is nullish, the current comparator will be outdated.
            // We cannot simply pass a nullish value to it, since it doesn't accept nullish.
            // Instead, we need to initialize a new comparator to reset it
            initializedComparator = comparator();
            previousWasNullish = true;
            return false;
        }
        previousWasNullish = false;
        return initializedComparator(current);
    };
};
exports.createOptionalValueEqualityCheck = createOptionalValueEqualityCheck;
//# sourceMappingURL=createEqualityChecks.js.map